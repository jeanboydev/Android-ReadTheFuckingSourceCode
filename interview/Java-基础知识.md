# Java 基础知识

## 基础知识
### 面向对象（OOP）的概念

-------

面向对象编程是使用类，对象，继承性，多态性，封装性和抽象的一种程序设计方法。

首先我们要区分一下“基于对象”和“面向对象”的区别。

1. 基于对象，通常指的是对数据的封装，以及提供一组方法对封装过的数据操作。
2. 面向对象，则在基于对象的基础上增加了多态性。所谓多态，就是可以用统一的方法对不同的对象进行同样的操作。

### 面向对象的三个基本元素和五个原则

-------

- 三个基本元素：

1. 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。
2. 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。
3. 多态： 多态性是指允许不同类的对象对同一消息作出响应。

- 五个基本原则：

1. 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。

2. 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。

3. Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

4. 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。

5. 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。

### 接口（Interface）与抽象类（Abstract Class）的区别

-------

- 抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。
- 接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。

### 覆盖（Overriding）与重载（OverLoading）的区别

-------

1. 覆盖是子类与父类之间的关系，是一种垂直关系；重载是同一个类中方法之间的关系，是水平关系
2. 覆盖只能由一个方法或者只能由一对方法产生关系；重载是多个方法之间的关系
3. 覆盖要求参数列表要相同；重载要求参数列表不同
4. 覆盖关系中，调用方法体是根据对象的类型（对象对应存储空间类型）决定，重载是根据调用的时候实参表和形参表来选择方法

### 序列化是什么？如何实现它？

-------

序列化是一种将对象转换为字节流的过程，目的是为了将该对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态及数据信息。

Java中，有两种方式可以实现序列化，既可以实现Serializable接口，也可以实现Parcelable接口。然而，在Android中，我们不应该使用Serializable接口。因为Serializable接口使用了反射机制，这个过程相对缓慢，而且往往会产生出很多临时对象，这样可能会触发垃圾回收器频繁地进行垃圾回收。相比而言，Parcelable接口比Serializable接口效率更高，性能方面要高出10x多倍。

### 什么是单例？

-------

单例模式指的是一个类只能被初始化一次，即只有一个实例。单例模式限定一个类只能拥有一个实例。这在系统中只需要一个实例来和其他模块协调工作时是很实用的。单例普遍使用在只需要一个或是限制一定数量实例的系统中。

### 什么是匿名内部类？内部类的作用

-------

普通的类可以自然地实例化他自己，相反地，内部类是这样的类： 一定要绑定上一个外部类才能进行实例化的类。而匿名内部类也就是没有名字的内部类，因为没有名字，所以只能使用一次。使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。

内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
创建内部类对象的时刻并不依赖于外围类对象的创建。
内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
内部类提供了更好的封装，除了该外围类，其他类都不能访问

### 对字符串进行 == 和 equals() 操作时有什么区别？

-------

== 比较两个字符串的地址，初学者很经常拿来比较其内容，将会导致出现不等的情况。 equals()是String这个类重写的一个方法，平常的类的equals()也仅仅是比较两个变量的地址，而String类的equals()重写后，将依次比较其串中的字符。

### hashCode() 和 equals() 何时使用？

-------

一般是在想要人性化地（而不是计算机式地,比较地址那样）比较两个对象的时候，我们需要使用这两个方法，或者说我们要重写这两个方法，而且有如下的原则：

1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；
2. 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；
3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；
4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

### Java 中的 final, finally 和 finalize？

-------

1. final: 修饰变量，方法，类； 修饰变量时表明这对象的值不可变，你不能为这个变量赋一个新的值，或者这样说：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用（而引用自身是可以改变的）。 修饰方法时表明我们希望把这个方法锁定，以防止任何继承类修改它的含义，这样会确保在继承中，我们的 final 方法的行为不会改变，并且不会被覆盖。使用 final 方法的另一个考虑是效率问题：在 Java 早期的时候，遇到 final 方法，编译器会将此方法调用转为内嵌调用，如此一来以减小方法调用产生的开销。 修饰类的时候表明你不打算继承该类，而且也不允许别人这样做。
2. finally: 是异常处理中进行收场处理的代码块，比如关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。
3. finalize: finalize出现的原因在于，我们一定需要进行清理动作。Java 没有用于释放对象的，如同 C++ 里的 delete 调用，的方法，而是使用垃圾回收器（GC）帮助我们释放空间。当垃圾回收器准备释放对象占用的存储空间的时候，将首先调用其 finalize()方法。


### Java 中 static 关键字是什么意思？

-------

static 是 Java 里的非访问修饰符，它可以用来创建类方法和类变量。

当修饰一个变量的时候，此变量就成了独立于对象的静态变量，无论一个类实例化了多少个对象，这个类只有一份这个静态变量的拷贝，所以 static 修饰的变量，即静态变量，也被叫做类变量。一个局部变量不能被声明为 static 变量。

当修饰一个方法的时候，此方法就成了独立于对象的静态方法，静态方法不能使用类的非静态变量，因为静态方法和静态变量先于非静态的其他成员初始化，静态方法先出来，然后才是非静态的，所以明白这个顺序很重要。静态方法从参数列表得到数据，然后计算这些数据。

### Java 中静态方法可以被重写吗？

-------

严格来说，不存在静态方法的重写，当一个子类继承父类时，写同样的方法时，只是将父类的静态方法隐藏。

### 在 Java 中什么是强引用、软引用、弱引用以及虚引用？

-------

强引用：不会被GC轻易清理，只要引用存在，垃圾回收器永远不会回收。
```Java
Object obj = new Object();
```

软引用： 非必须引用，内存溢出之前进行回收
```Java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null
```

弱引用： 第二次垃圾回收时回收
```Java 
Object obj = new Object(); 
WeakReference wf = new WeakReference(obj); 
obj = null; wf.get();//有时候会返回null 
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
```

虚引用： 垃圾回收时回收，无法通过引用取到对象值
```Java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
```

## 数据结构


### Arrays 和 ArrayList 之间的区别

-------

Arrays：一个包含许多和操纵数组有关方法的类，比如排序和查找，它继承自 Object 类。
ArraysList：是一个容器，它可以实现数组的大小可变，方便地增加和删除元素。它实现了 List 接口的类。

### ArrayList、LinkedList、Vector 之间的区别

-------

- ArrayList 实现了可变大小的数组。它允许 null。ArrayList 没有同步。增删慢，查询快。
- LinkedList 实现了 List 接口，允许null元素。此外 LinkedList 提供额外的 get，remove，insert 方法在 LinkedList 的首部或尾部。LinkedList 不是同步的（不是线程安全）。实现线程安全：List list = Collections.synchronizedList(new LinkedList(...)); 增删快，查询慢。

关于 ArrayList 和 Vector 区别如下：

1. ArrayList 在内存不够时默认是扩展 50% + 1 个，Vector 是默认扩展1倍。
2. Vector 提供 indexOf(obj, start) 接口，ArrayList 没有。
3. Vector 属于线程安全级别的，但是大多数情况下不使用 Vector，因为线程安全需要更大的系统开销。


### HashMap的实现原理

-------

HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

HashMap的数据结构：在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。

### HashMap 和 HashTable 之间的区别

-------

HashMap 和 Hashtable 都实现了 Map 接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。

1. HashMap 几乎可以等价于 HashTable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值 key 和值 value，而 HashTable 则不行)。
2. HashMap 是非 synchronized，而 HashTable 是 synchronized，这意味着 HashTable 是线程安全的，多个线程可以共享一个 HashTable；而如果没有正确的同步的话，多个线程是不能共享 HashMap 的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable  的扩展性更好。
3. 另一个区别是 HashMap 的迭代器 Iterator 是 fail-fast 迭代器，而 HashTable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出 ConcurrentModificationException，但迭代器本身的 remove() 方法移除元素则不会抛出 ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是 Enumeration 和 Iterator 的区别。
4. 由于 HashTable 是线程安全的也是 synchronized，所以在单线程环境下它 比HashMap 要慢。如果你不需要同步，只需要单一线程，那么使用 HashMap 性能要好过 Hashtable。
5. HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。


### HashSet 和 TreeSet 之间的区别

-------

TreeSet 是基于二叉树实现的，其中的数据是自动排序好的。不允许放入 null 值。
HashSet 是基于 Hash 表实现的，其中的数据是无序的，允许放入 null 值。


### Integer 和 int 之间的区别

-------

1. Integer 是 int 提供的封装类，而 int 是 Java 的基本数据类型； Integer 默认值是 null，而 int 默认值是0； 声明为 Integer 的变量需要实例化，而声明为 int 的变量不需要实例化； Integer 是对象，用一个引用指向这个对象，而 int 是基本类型，直接存储数值
2. 两个 new 出来的 Integer总 是不一样的。当使用 == 时，发现其内存地址不同，所以进行 == 返回 false
3. 两个不是 new 出来的 Integer，而是诸如 Integer i = x，如果 x 的范围在 -128～127，因为如下语句： Integer i5 = 127;//java 在编译的时候，被翻译成 -> Integer i5 = Integer.valueOf(127); 调用了 Integer.valueOf()， 这会将 127 缓存，下次我们写：Integer i6 = 127; 时，i6 指向缓存中的同一个对象。所以此时 i5==i6 是 true； 当 x 范围在 -128～127 之外，没有缓存存在，即使他们包裹的数值相等，他们也不能使用 == 的到 true。
4. int 和 Integer 的比较，无论 Integer 是否使用 new，其值和将和平常的预料的一样: Integer 自动拆箱，然后和 int 比较数值。这里就不会被内存地址的不同所影响，该相等时就相等。

### String、StringBuffer、StringBuilder 的区别

-------

- String 字符串常量
- StringBuffer 字符串变量（线程安全）
- StringBuilder 字符串变量（非线程安全）

简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。

而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的。

- 在大部分情况下 StringBuffer > String

Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。

可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。

StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。

- 在大部分情况下 StringBuilder > StringBuffer

java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同

### Java 那些类是 final？

-------

String，Match



## 线程相关
### 关键字 synchronized 的作用是什么？Lock 相关

-------

synchronized 通过修饰一个方法或者代码块，从而产生一个同步对象锁，以及对应的同步代码块。每当有线程要对该同步代码块进行访问时，线程就会首先尝试获取这个对象的锁，并在成功获取到对象锁后，对这个同步代码块进行正常的访问。在同步代码块的访问过程中，线程会一直持有这个对象锁，直到同步代码块访问完毕，然后才会释放。

在上述线程持有同步锁并进行同步代码块访问过程中，其它线程将无法获得该对象锁，也无法访问该同步代码，这些线程都会被阻塞直到上述线程访问完毕。

### 修饰符 transient 和 volatile 的作用是什么？

-------

volatile：易式修饰符

出现它的原因是，java 的多线程中存在两个或多个线程时间间隔很短地访问共享成员变量（指被多个线程共享的变量），在每个线程自己的工作内存中，可能对这个变量进行修改，但是没有及时将工作内存中的变量（对原本的共享成员变量的一份拷贝）写回共享成员变量，此时，当另外一个线程进行读取时，将无法得到最新的此变量，导致进程的工作不能正确进行。

于是出现了volatile，带有 volatile 修饰的变量，就是当其在某个线程自己的工作内存中发生改变时，会被强制地，写回公共成员变量所在的公共内存处。

如此便保证了，所有线程对这个变量的访问都是能得到此变量最新状态的访问。

transient：
transient是一个类型修饰符，仅仅能用来修饰字段（变量）。在此字段所在的对象进行序列化的时候，这个字段不会被序列化。

其他没有 transient 修饰的变量将会被序列化，然后进行传输，或者存储到本地磁盘，transient 变量就在这个过程里丢失了。

### Java 中的多线程：Thread，Runnable

-------

一个线程对象只能启动一个线程，无论你调用多少遍 start() 方法，结果只有一个线程。

实现 Runnable 接口相对于继承 Thread 类的优点：

1. 适合多个相同程序代码的线程去处理同一资源的情况，把虚拟 CPU（线程）同程序的代码，数据有效的分离，较好地体现了面向对象的设计思想。 
2. 可以避免由于 Java 的单继承特性带来的局限。我们经常碰到这样一种情况，即当我们要将已经继承了某一个类的子类放入多线程中，由于一个类不能同时有两个父类，所以不能用继承 Thread 类的方式，那么，这个类就只能采用实现 Runnable 接口的方式了。 
3. 有利于程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。当多个线程的执行代码来自同一个类的实例时，即称它们共享相同的代码。多个线程操作相同的数据，与它们的代码无关。当共享访问相同的对象是，即它们共享相同的数据。当线程被构造时，需要的代码和数据通过一个对象作为构造函数实参传递进去，这个对象就是一个实现了 Runnable 接口的类的实例。 


### 进程和线程区别？

-------

简而言之,一个程序至少有一个进程,一个进程至少有一个线程。

线程的划分尺度小于进程，使得多线程程序的并发性高。

另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。


### 线程中 sleep() 和 wait() 有什么区别，各有什么含义？

-------

对于sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait() 方法，则是属于 Object 类中的。 

- sleep() 方法导致了程序暂停执行指定的时间，让出 CPU 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 在调用 sleep() 方法的过程中，线程不会释放对象锁。
- 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。

### 如何做到多个线程访问同一个数组，既要线程安全，同时提高读写效率？

-------


### 什么导致线程阻塞

-------

线程的阻塞

为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.

阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。

sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。

suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。

yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.

wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.

初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。

首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。

其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。

wait() 和 notify() 方法的上述特性决定了它们经常和synchronized方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。

- 关于 wait() 和 notify() 方法最后再说明两点：

1. 调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。

2. 除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。


## 虚拟机相关
### 简述垃圾回收器的工作原理

-------

Java的垃圾回收机制是Java虚拟机提供的能力，用于在空闲时间以不定时的方式动态回收无任何引用的对象占据的内存空间。

- 引用计数器
- 停止-复制
- 标记-清除
- 标记-压缩
- 分代


### String a = "a"+"b"+"c" 在内存中创建几个对象？

-------

这个问题涉及到了字符串常量池和字符串拼接
```Java
String a = "a"+"b"+"c"
```

通过编译器优化后，得到的效果是
```Java
String a = "abc"
```

此时，如果字符串常量池中存在 abc，则该语句并不会创建对象，只是讲字符串常量池中的引用返回而已。

如果字符串常量池中不存在 abc，则会创建并放入字符串常量池，并返回引用，此时会有一个对象进行创建。

两个深入阅读的链接：

- 字符串常量池： http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/  
- 字符串拼接内部实现：http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/

### Java 类的加载过程？

-------

1. 加载时机：创建实例、访问静态变量或方法、反射、加载子类之前
2. 验证：验证文件格式、元数据、字节码、符号引用的正确性
3. 加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成 class 对象
4. 准备：在堆上为静态变量划分内存
5. 解析：将常量池中的符号引用转换为直接引用
6. 初始化：初始化静态变量

### ClassLoader 的基础知识

-------

- 双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。
- 可以动态加载Jar通过URLClassLoader
- ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。
- 加载不同Jar包中的公共类：
	1. 让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java)
	2. 重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java)
	3. 在生成包含公共Jar的Jar时候把公共Jar去掉。

### 如何判断对象的生死？垃圾回收算法？新生代，老生代？

-------

- [JVM 内存分配机制](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/JVM/JVM-内存分配机制.md)
如何确定某个对象是垃圾：
1. 引用计数法
2. 可达性分析

- [JVM 垃圾回收机制](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/JVM/JVM-垃圾回收机制.md)
典型的垃圾回收算法：
1. 标记-清除算法(Mark-Sweep)
2. 复制算法(Copying)
3. 标记-整理算法(Mark-Compact)
4. 分代收集算法(Generational Collection)

### 哪些情况下的对象会被垃圾回收机制处理掉

-------

Java垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。


## 其他
### Java5，Java6，Java7，Java8，Java9版本特性

-------

Java Version SE 5.0
开发代号为 Tiger（老虎），于 2004-09-30 发行。

引入的新特性包括:

- 引入泛型；
- 增强循环，可以使用迭代方式；
- 自动装箱与自动拆箱；
- 类型安全的枚举；
- 可变参数；
- 静态引入；
- 元数据（注解）；
- 引入 Instrumentation。

Java Version SE 6
开发代号为 Mustang（野马），于 2006-12-11 发行。

引入的新特性包括：

- 支持脚本语言；
- 引入 JDBC 4.0 API；
- 引入 Java Compiler API；
- 可插拔注解；
- 增加对 Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持；
- 继承 Web Services；
- 做了很多优化。

Java Version SE 7
开发代号是 Dolphin（海豚），于 2011-07-28 发行。

引入的新特性包括：

- switch 语句块中允许以字符串作为分支条件；
- 在创建泛型对象时应用类型推断；
- 在一个语句块中捕获多种异常；
- 支持动态语言；
- 支持 try-with-resources；
- 引入 Java NIO.2 开发包；
- 数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；
- 钻石型语法；
- null 值的自动处理。

Java SE 8
Java 8 是于 2014-3-14 发布。从 Java 8 开始开发代号已经弃用了，所以从 Java 8 之后已经没有官方的开发代号了。

Java SE 8 中的新特性

- Lambda 表达式
- Pipelines 和 Streams
- Date 和 Time API
- Default 方法
- Type 注解
- Nashhorn JavaScript 引擎
- 并发计数器
- Parallel 操作
- 移除 PermGen Error
- TLS SNI

Java SE 9

Java 9 是于 2017-9-21 发布。

Java SE 9 中的新特性

- Java 平台级模块系统
- Linking
- JShell: 交互式 Java REPL
- 改进的 Javadoc
- 集合工厂方法
- 改进的 Stream API
- 私有接口方法
- HTTP/2
- 多版本兼容 JAR

### Java NIO 是啥？

-------

java.nio 全称 java non-blocking IO，是指 jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。

Java NIO 是在 jdk1.4 开始使用的，它既可以说成“新 I/O”，也可以说成非阻塞式 I/O。

1. 由一个专门的线程来处理所有的 IO 事件，并负责分发。 
2. 事件驱动机制：事件到的时候触发，而不是同步的去监视事件。 
3. 线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。




